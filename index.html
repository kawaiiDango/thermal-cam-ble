<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body,
      html {
        background-color: #000;
        margin: 0;
        padding: 0;
        text-align: center;
        color: #999;
        display: flex;
        flex-direction: column;
      }

      select,
      button {
        background-color: #000;
        color: #999;
        border: solid 1px #999;
      }

      button {
        font-size: large;
        margin-top: 10px;
      }

      .m-top {
        margin-top: 10px;
      }

      .m-horizontal {
        margin-left: 2%;
        margin-right: 2%;
      }

      #image,
      #settings {
        overflow: hidden;
        position: relative;
      }

      #settings {
        padding: 24px;
      }

      #imageContainer {
        display: inline-block;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        overflow: hidden;
      }

      @media (orientation: portrait) {
        #imageContainer {
          width: 100%;
          padding-top: calc(3 / 4 * 100% + 48px);
        }
      }

      @media (orientation: landscape) {
        #imageContainer {
          width: calc(100% - 4 / 3 * 48px);
          padding-top: calc(3 / 4 * 100%);
        }
      }

      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .flex {
        display: flex;
        justify-content: space-between;
      }

      .flex-1 {
        flex: 1;
      }

      .flex-c {
        flex-direction: column;
      }

      .center {
        text-align: center;
      }

      .hide {
        display: none;
      }

      #rangeSetting {
        border-bottom: solid 1px #ddd;
        padding-bottom: 2px;
        margin-bottom: 5px;
      }

      label {
        display: flex;
        flex-direction: column;
        flex: 1;
      }

      label input {
        align-self: center;
        width: 100%;
      }

      @media (orientation: landscape) {
        body {
          flex-direction: row;
        }
        #settings {
          flex: 1;
        }
        #image {
          width: calc(4 / 3 * 100vh);
        }
      }
    </style>

    <script>
      Color = function (hexOrObject) {
        let obj;
        if (hexOrObject instanceof Object) {
          obj = hexOrObject;
        } else {
          obj = LinearColorInterpolator.convertHexToRgb(hexOrObject);
        }
        this.r = obj.r;
        this.g = obj.g;
        this.b = obj.b;
        this.a = obj.a;
      };
      Color.prototype.asRgbCss = function () {
        return (
          "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")"
        );
      };

      var LinearColorInterpolator = {
        convertHexToRgb: function (hex) {
          const match = hex.replace(/#/, "").match(/.{1,2}/g);
          return new Color({
            r: parseInt(match[0], 16),
            g: parseInt(match[1], 16),
            b: parseInt(match[2], 16),
            a: hex.length > 7 ? parseInt(match[3], 16) : 255,
          });
        },
        findColorBetween: function (left, right, percentage) {
          const newColor = {};
          const components = ["r", "g", "b", "a"];
          for (let i = 0; i < components.length; i++) {
            const c = components[i];
            newColor[c] = Math.round(
              left[c] + ((right[c] - left[c]) * percentage) / 100
            );
          }
          return new Color(newColor);
        },
      };
    </script>
  </head>

  <body>
    <div id="image">
      <div id="imageContainer">
        <canvas id="canvas"></canvas>
      </div>
    </div>
    <div id="settings">
      <div class="flex">
        <label id="minContainer"
          ><span>Min <span id="minSetting"></span></span
          ><input
            type="range"
            id="minValue"
            min="-20"
            max="100"
            step="1"
            value="20"
            oninput="updateSettings()"
        /></label>
        <label id="distanceContainer"
          ><span>Min Distance <span id="distanceSetting"></span></span
          ><input
            type="range"
            id="distanceValue"
            min="0"
            max="15"
            step="1"
            value="5"
            oninput="updateSettings()"
        /></label>
        <label id="maxContainer"
          ><span>Max <span id="maxSetting"></span></span
          ><input
            type="range"
            id="maxValue"
            min="-20"
            max="100"
            step="1"
            value="40"
            oninput="updateSettings()"
        /></label>
      </div>
      <div class="flex">
        <div class="flex flex-1 flex-c">
          <label
            >Adaptive<input
              type="checkbox"
              id="adaptiveValue"
              checked
              onchange="updateSettings()"
          /></label>
          <label
            >Average<input
              type="checkbox"
              id="avgValue"
              onchange="updateSettings()"
          /></label>
          <label
            >Webcam<input
              type="checkbox"
              id="webcamEnabled"
              onchange="updateSettings()"
          /></label>
        </div>
        <div class="flex flex-1 flex-c">
          <label
            >Palette<select
              id="paletteValue"
              onchange="updateSettings()"
            ></select
          ></label>
          <label id="fpsLabel" for="hardwareFpsValue">Fps</label>
          <select id="hardwareFpsValue" onchange="setFpsValue()"></select>
          <label
            ><span>Opacity <span id="opacitySetting"></span></span
            ><input
              type="range"
              id="opacityValue"
              min="0"
              max="100"
              step="5"
              value="75"
              disabled
              oninput="updateSettings()"
          /></label>
        </div>
      </div>
      <div class="flex hide" id="offsetContainer">
        <div class="flex flex-1 m-horizontal">
          <button id="offsetXMinus">-</button>
          <span id="offsetX" class="m-top">X: </span>
          <button id="offsetXPlus">+</button>
        </div>
        <div class="flex flex-1 m-horizontal">
          <button id="offsetYMinus">-</button>
          <span id="offsetY" class="m-top">Y:</span>
          <button id="offsetYPlus">+</button>
        </div>
        <div class="flex flex-1 m-horizontal" style="vertical-align: middle">
          <button id="scaleMinus">-</button>
          <span id="scale" class="m-top">S:</span>
          <button id="scalePlus">+</button>
        </div>
      </div>
      <div class="center">
        <button id="connectDisconnect">Connect</button>
      </div>
      <div class="center">
        <button id="capture">Capture</button>
      </div>
      <div id="status" class="m-top center">
        <span id="debugStatus"></span>
      </div>
    </div>
    <script>
      const sizeX = 32;
      const sizeY = 24;
      const multiplier = 20;
      const numParts = 4;
      const pixelRatio = Math.floor(window.devicePixelRatio || 1);
      const valueTableFontSize = 12 * pixelRatio;
      const markerFontSize = 15 * pixelRatio;

      let rangeMin = 20;
      let rangeMax = 40;
      let adaptiveRange = true;
      const palettes = [
        {
          name: "FLIR Transparent",
          stops: ["#00000000", "#20008C", "#CC0077", "#FFD700", "#FFFFFF"],
        },
        {
          name: "FLIR",
          stops: ["#000000", "#20008C", "#CC0077", "#FFD700", "#FFFFFF"],
        },
        {
          name: "BW Transparent",
          stops: ["#00000000", "#FFFFFF"],
        },
        {
          name: "BW",
          stops: ["#000000", "#FFFFFF"],
        },
        {
          name: "WB Transparent",
          stops: ["#FFFFFF00", "#000000"],
        },
        {
          name: "WB",
          stops: ["#FFFFFF", "#000000"],
        },
      ];
      let currentPalette = palettes[0];
      let accumlator = [];
      let average = false;
      let imageLoading = false;
      let markerCoords = null;
      let mindistance = 10;
      let lastFrameReceiveTime = 0;
      let opacity = 75;
      let webcamEnabled = false;
      const offsetStep = 0.02;
      const offset = { x: 0, y: 0, scale: 1 };

      const tempsFrame = new Float32Array(sizeX * sizeY);

      //Define BLE Device Specs
      const deviceName = "thermalCam";
      const camServiceUuid = "38185cd8-4e17-e1b8-554f-dfe74135dde5";
      const tempsFrameCharacteristicUuid =
        "be55aaa5-8188-4063-8a57-eea168985662";
      const camFpsFloatDescUuid = "9c54c864-fe2e-4f5f-96c0-793147ec8094";

      //Global Variables to Handle Bluetooth
      let bleDevice = null;
      let gattServer = null;
      let camFpsFloatDesc = null;
      let tempsFrameCharacteristic = null;
      let watchAdvAbortController = null;

      // webcam variables
      let videoFeed = null;

      // DOM elements
      const captureButton = document.getElementById("capture");
      const connectDisconnectButton =
        document.getElementById("connectDisconnect");
      const statusContainer = document.getElementById("debugStatus");
      const mainCanvasElem = document.getElementById("canvas");
      const fpsLabelElem = document.getElementById("fpsLabel");
      const paletteValue = document.getElementById("paletteValue");
      const hardwareFpsValue = document.getElementById("hardwareFpsValue");
      const opacityValue = document.getElementById("opacityValue");
      const minValue = document.getElementById("minValue");
      const maxValue = document.getElementById("maxValue");
      const distanceValue = document.getElementById("distanceValue");
      const adaptiveValue = document.getElementById("adaptiveValue");
      const avgValue = document.getElementById("avgValue");
      const opacitySetting = document.getElementById("opacitySetting");
      const distanceContainer = document.getElementById("distanceContainer");
      const minContainer = document.getElementById("minContainer");
      const maxContainer = document.getElementById("maxContainer");
      const minSetting = document.getElementById("minSetting");
      const maxSetting = document.getElementById("maxSetting");
      const distanceSetting = document.getElementById("distanceSetting");
      const webcamEnabledValue = document.getElementById("webcamEnabled");
      const offsetContainer = document.getElementById("offsetContainer");
      const offsetXSpan = document.getElementById("offsetX");
      const offsetXMinus = document.getElementById("offsetXMinus");
      const offsetXPlus = document.getElementById("offsetXPlus");
      const offsetYSpan = document.getElementById("offsetY");
      const offsetYMinus = document.getElementById("offsetYMinus");
      const offsetYPlus = document.getElementById("offsetYPlus");
      const scaleSpan = document.getElementById("scale");
      const scaleMinus = document.getElementById("scaleMinus");
      const scalePlus = document.getElementById("scalePlus");
      const webcamVideoElem = document.createElement("video");
      const thermCanvasElem = document.createElement("canvas");
      const thermCtx = thermCanvasElem.getContext("2d", {
        willReadFrequently: false,
      });
      const finalCanvasCtx = mainCanvasElem.getContext("2d", {
        willReadFrequently: false,
        alpha: false, // text anti-aliasing
      });

      // functions

      function pDelay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function connectDisconnect() {
        if (!navigator.bluetooth) {
          statusContainer.innerHTML =
            "Web Bluetooth API is not available in this browser!";
          return;
        }

        if (connectDisconnectButton.innerHTML === "Connect") {
          if (
            bleDevice &&
            watchAdvAbortController &&
            watchAdvAbortController.signal.aborted
          ) {
            autoConnect(bleDevice);
          } else {
            // no saved device, or already auto connectinng, force show device chooser
            showDeviceChooser();
          }
        } else {
          disconnectDevice();
        }
      }

      async function showDeviceChooser() {
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [
            {
              name: deviceName,
              // services: [gapServiceUuid]
            },
          ],
          // acceptAllDevices : true,
          optionalServices: [camServiceUuid],
        });

        connectToDevice(bleDevice);
      }

      async function connectToDevice(device) {
        try {
          if (watchAdvAbortController) watchAdvAbortController.abort();

          bleDevice = device;
          device.addEventListener("gattserverdisconnected", disconnectDevice);

          gattServer = await device.gatt.connect();
          console.log("Connected to GATT Server");

          const cameraService = await gattServer.getPrimaryService(
            camServiceUuid
          );

          tempsFrameCharacteristic = await cameraService.getCharacteristic(
            tempsFrameCharacteristicUuid
          );

          lastFrameReceiveTime = Date.now();

          tempsFrameCharacteristic.addEventListener(
            "characteristicvaluechanged",
            handleTempsCharacteristicChange
          );

          await tempsFrameCharacteristic.startNotifications();

          camFpsFloatDesc = await tempsFrameCharacteristic.getDescriptor(
            camFpsFloatDescUuid
          );

          console.log("Notifications Started.");

          await readFpsValue();

          connectDisconnectButton.innerHTML = "Disconnect";
          captureButton.classList.remove("hide");

          if (webcamEnabled) {
            startWebcam();
          }
        } catch (error) {
          statusContainer.innerHTML = "Error: " + error;
          console.error("Error: ", error);
          disconnectDevice();
        }
      }

      async function autoConnectSetup() {
        try {
          const devices = await navigator.bluetooth.getDevices();
          console.log("devices:", devices);
          const thermalCamDevice = devices.find(
            (device) => device.name === deviceName
          );

          if (thermalCamDevice) {
            thermalCamDevice.addEventListener(
              "advertisementreceived",
              (event) => {
                connectToDevice(event.device);
              }
            );

            autoConnect(thermalCamDevice);
          }
        } catch (error) {
          // feature is probably not enabled
          statusContainer.innerHTML =
            "Try to enable chrome://flags/#enable-experimental-web-platform-features and chrome://flags/#enable-web-bluetooth-new-permissions-backend";
          console.error("Error: ", error);
        }
      }

      async function autoConnect(device) {
        watchAdvAbortController = new AbortController();
        await device.watchAdvertisements({
          signal: watchAdvAbortController.signal,
        });

        statusContainer.innerHTML = `Auto connecting to ${deviceName}...`;
      }

      async function disconnectDevice(event) {
        statusContainer.innerHTML = "";

        if (watchAdvAbortController) watchAdvAbortController.abort();

        try {
          bleDevice.removeEventListener(
            "gattserverdisconnected",
            disconnectDevice
          );
        } catch (error) {
          console.error("An error occurred:", error);
        }

        console.log("Disconnect");

        if (tempsFrameCharacteristic) {
          tempsFrameCharacteristic.removeEventListener(
            "characteristicvaluechanged",
            handleTempsCharacteristicChange
          );
          try {
            console.log("Notifications Stopped");
            await tempsFrameCharacteristic.stopNotifications();
          } catch (error) {
            console.error("An error occurred:", error);
          }

          tempsFrameCharacteristic = null;
        }

        if (gattServer && gattServer.connected) {
          try {
            await gattServer.disconnect();
            console.log("Device Disconnected");
          } catch (error) {
            console.error("An error occurred:", error);
          }
          gattServer = null;
          camFpsFloatDesc = null;
        } else {
          // Throw an error if Bluetooth is not connected
          statusContainer.innerHTML = "Bluetooth is not connected.";
        }

        connectDisconnectButton.innerHTML = "Connect";
        captureButton.classList.add("hide");

        if (videoFeed) {
          stopWebcam();
        }

        // auto reconnect if event is undefined
        if (event) {
          await pDelay(2000);
          autoConnect(bleDevice);
        }
      }

      function handleTempsCharacteristicChange(event) {
        const dataView = event.target.value;

        const seq = new Int16Array(dataView.buffer.slice(0, 2))[0];

        if (seq < 0 || seq >= numParts) {
          console.error("Invalid sequence number: ", seq);
          return;
        }

        const temperaturesX100 = new Int16Array(
          dataView.buffer.slice(2, (sizeX * sizeY * 2) / numParts + 2)
        );

        // restore the float32 temperatures from the 16 bit integers by dividing by 100
        for (let i = 0; i < temperaturesX100.length; i++) {
          tempsFrame[(sizeX * sizeY * seq) / numParts + i] =
            temperaturesX100[i] / 100.0;
        }

        if (seq == numParts - 1) {
          // the last frame contains additional stats
          const stats = new Float32Array(3);
          const statusX100 = new Int16Array(
            dataView.buffer.slice(
              ((sizeX * sizeY) / numParts) * 2 + 2,
              dataView.buffer.byteLength
            )
          );

          // restore the float32 stats values from the 16 bit integers by dividing by 100
          for (let i = 0; i < stats.length; i++) {
            stats[i] = statusX100[i] / 100.0;
          }

          //     struct status_t
          // {
          //     float t_a;
          //     float battery_voltage;
          //     float free_heap_k;
          // };
          const statsText = `Ta: ${Math.round(stats[0] * 10) / 10}°C | Batt: ${
            Math.round(stats[1] * 100) / 100
          }V | Free: ${Math.round(stats[2] * 100) / 100}kB`;

          statusContainer.innerHTML = statsText;

          fpsLabelElem.innerText = `FPS: (${(
            1000 /
            (Date.now() - lastFrameReceiveTime)
          ).toFixed(2)})`;
          lastFrameReceiveTime = Date.now();

          console.log("Frame received");

          if (average) {
            if (accumlator == null || accumlator.length != tempsFrame.length) {
              accumlator = tempsFrame;
            } else {
              accumlator.forEach((elem, index) => {
                accumlator[index] =
                  Math.round(((elem + tempsFrame[index]) / 2) * 10) / 10;
              });
              drawAllCanvases(accumlator);
            }
          } else {
            drawAllCanvases(tempsFrame);
          }
        }
      }

      function drawThermCanvas(therm, min, max) {
        const ctx = thermCtx;
        thermCanvasElem.width = sizeX;
        thermCanvasElem.height = sizeY;
        const canvasWidth = sizeX;
        const canvasHeight = sizeY;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        const id = ctx.getImageData(0, 0, sizeX, sizeY);
        var pixels = id.data;

        let thermCount = 0;
        for (var y = 0; y < sizeY; y++) {
          for (var x = 0; x < sizeX; x++) {
            const val = map(therm[thermCount], min, max, 0, 100);
            const off = (y * id.width + (sizeX - 1 - x)) * 4;

            const color = getPaletteColor(val);
            pixels[off] = color.r;
            pixels[off + 1] = color.g;
            pixels[off + 2] = color.b;
            pixels[off + 3] = color.a;
            thermCount++;
          }
        }
        ctx.putImageData(id, 0, 0, 0, 0, sizeX, sizeY);
      }

      function drawRangeLegend(min, max) {
        const ctx = finalCanvasCtx;
        const canvasWidth = mainCanvasElem.width;
        const canvasHeight = mainCanvasElem.height;
        const numStops = currentPalette.stops.length;

        const segmentWidth = canvasWidth / numStops;

        let valueTable = "";
        const gradientHeight = 10 * pixelRatio; // Height of the gradient bar
        const yPosValueTable =
          canvasHeight - valueTableFontSize - markerFontSize - 5; // 5= add some space
        const yPosGradient = yPosValueTable - 2 * gradientHeight; // Y position to start drawing the gradient bar

        const gradient = ctx.createLinearGradient(
          0,
          yPosGradient,
          mainCanvasElem.width,
          yPosGradient
        );

        // Loop through each stop in the currentPalette and add it to the gradient
        currentPalette.stops.forEach((color, index) => {
          const position = index / (currentPalette.stops.length - 1);
          gradient.addColorStop(position, color);
        });

        // Apply the gradient as fill style and draw the rectangle
        ctx.fillStyle = gradient;
        ctx.fillRect(0, yPosGradient, mainCanvasElem.width, gradientHeight);

        // Draw the value table

        ctx.font = `${valueTableFontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#bbb";

        for (let i = 0; i <= numStops; i++) {
          const value = min + ((max - min) / numStops) * i;
          const roundedValue = Math.round(value * 10) / 10;
          let xPos = (canvasWidth / numStops) * i;

          // Measure text width
          const textWidth = ctx.measureText(roundedValue.toString()).width;

          // Adjust xPos for the first value
          if (i === 0) {
            xPos = Math.max(xPos, textWidth / 2);
          }
          // Adjust xPos for the last value
          else if (i === numStops) {
            xPos = Math.min(xPos, canvasWidth - textWidth / 2);
          }

          ctx.fillText(roundedValue.toString(), xPos, yPosValueTable);
        }
      }

      function drawMarker(markerValue) {
        const ctx = finalCanvasCtx;
        const canvasWidth = mainCanvasElem.width;
        const canvasHeight = mainCanvasElem.height;
        const markerSize = 10 * pixelRatio;

        ctx.font = `${markerFontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#ddd";

        const text = `${markerCoords ? "Marker" : "Center"}: ${
          Math.round(markerValue * 10) / 10
        }°C`;

        ctx.fillText(text, canvasWidth / 2, canvasHeight - markerFontSize);

        if (markerCoords) {
          const clickX = markerCoords.x;
          const clickY = markerCoords.y;

          // Configure shadow
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)"; // Shadow color with some transparency
          ctx.shadowBlur = 4 * pixelRatio;
          ctx.shadowOffsetX = 2 * pixelRatio;
          ctx.shadowOffsetY = 2 * pixelRatio;

          ctx.beginPath();
          ctx.moveTo(clickX - markerSize, clickY); // Horizontal line left part
          ctx.lineTo(clickX + markerSize, clickY); // Horizontal line right part
          ctx.moveTo(clickX, clickY - markerSize); // Vertical line top part
          ctx.lineTo(clickX, clickY + markerSize); // Vertical line bottom part
          ctx.strokeStyle = "#0FF"; // Set the color of the crosshair
          ctx.stroke();

          // Reset shadow to default (no shadow) to avoid affecting other drawings
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }

      function drawWebcamFrame() {
        const videoFeedAspectRatio =
          webcamVideoElem.videoWidth / webcamVideoElem.videoHeight;
        const scale =
          webcamVideoElem.videoWidth / offset.scale / mainCanvasElem.width;

        const offsetX = -offset.x * mainCanvasElem.width;
        const offsetY = -offset.y * mainCanvasElem.height;

        const srcX = Math.max(0, offsetX * scale);
        const srcY = Math.max(0, offsetY * scale);

        const dstX = Math.max(0, -offsetX);
        const dstY = Math.max(0, -offsetY);

        const shiftX = Math.max(dstX * scale, srcX);
        const shiftY = Math.max(dstY * scale, srcY);

        const srcWidth = Math.min(
          webcamVideoElem.videoWidth - shiftX,
          mainCanvasElem.width * scale
        );
        const srcHeight = Math.min(
          webcamVideoElem.videoHeight - shiftY,
          mainCanvasElem.height * scale
        );

        const dstWidth = srcWidth / scale;
        const dstHeight = srcHeight / scale;

        finalCanvasCtx.drawImage(
          webcamVideoElem,
          srcX,
          srcY,
          srcWidth,
          srcHeight,
          dstX,
          dstY,
          dstWidth,
          dstHeight
        );
      }

      function drawAllCanvases(therm) {
        if (therm == undefined) {
          therm = accumlator;
        }
        if (therm.length != sizeX * sizeY) {
          return;
        }

        let min;
        let max;

        if (adaptiveRange) {
          const thermMin = Math.min(...therm);
          const thermMax = Math.max(...therm);
          const thermCenter = thermMin + (thermMax - thermMin) / 2;
          min = thermMin;
          max = thermMax;
          if (thermMax - thermMin < mindistance) {
            min = Math.round((thermCenter - mindistance / 2) * 10) / 10;
            max = Math.round((thermCenter + mindistance / 2) * 10) / 10;
          }
        } else {
          min = rangeMin;
          max = rangeMax;
        }

        drawThermCanvas(therm, min, max);

        mainCanvasElem.width = mainCanvasElem.clientWidth * pixelRatio;
        mainCanvasElem.height = mainCanvasElem.clientHeight * pixelRatio;

        finalCanvasCtx.clearRect(
          0,
          0,
          mainCanvasElem.width,
          mainCanvasElem.width * (3 / 4)
        );

        // Draw the webcam image

        if (videoFeed) {
          drawWebcamFrame();
          finalCanvasCtx.globalAlpha = opacity / 100;
        }

        finalCanvasCtx.drawImage(
          thermCanvasElem,
          0,
          0,
          sizeX,
          sizeY,
          0,
          0,
          mainCanvasElem.width,
          mainCanvasElem.width * (sizeY / sizeX)
        );

        finalCanvasCtx.globalAlpha = 1;

        // draw a black rect again, in case the webcam image overflows

        finalCanvasCtx.clearRect(
          0,
          mainCanvasElem.width * (3 / 4) + 1,
          mainCanvasElem.width,
          mainCanvasElem.height
        );

        drawRangeLegend(min, max);

        let markerValue;
        if (markerCoords) {
          markerValue =
            therm[
              markerCoords.yTherm * sizeX + (sizeX - 1 - markerCoords.xTherm)
            ];
        } else {
          markerValue = therm[(sizeY / 2) * sizeX + sizeX / 2];
        }

        drawMarker(markerValue);
      }

      async function readFpsValue() {
        // read from the device
        const data = await camFpsFloatDesc.readValue();
        const floatVal = new Float32Array(data.buffer)[0];
        hardwareFpsValue.value = floatVal;
      }

      async function setFpsValue() {
        // send to the device
        console.log("Setting FPS to: ", hardwareFpsValue.value);
        const fps = parseFloat(hardwareFpsValue.value);
        const data = new Float32Array([fps]);
        await camFpsFloatDesc.writeValue(data.buffer);
      }

      function stopWebcam() {
        videoFeed.getTracks().forEach((track) => {
          track.stop();
        });
        videoFeed = null;
        webcamVideoElem.srcObject = null;
        opacityValue.disabled = true;
        offsetContainer.classList.add("hide");
      }

      async function startWebcam() {
        try {
          videoFeed = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: Math.max(1, hardwareFpsValue.value) },
              // rear camera, the thermal camera will be attached to the back of the phone with a holder
              facingMode: { ideal: "environment" },
            },
            audio: false,
          });
          webcamVideoElem.srcObject = videoFeed;
          webcamVideoElem.play();

          opacityValue.disabled = false;
          offsetContainer.classList.remove("hide");
        } catch (error) {
          console.error("Error: ", error);
          webcamEnabledValue.checked = false;
        }
      }

      function updateOffsets(offsetDelta) {
        if (offsetDelta) {
          if (offsetDelta.x)
            offset.x = Math.min(Math.max(offsetDelta.x + offset.x, -10), 10);
          if (offsetDelta.y)
            offset.y = Math.min(Math.max(offsetDelta.y + offset.y, -10), 10);
          if (offsetDelta.scale)
            offset.scale = Math.min(
              Math.max(offsetDelta.scale + offset.scale, 0.5),
              2
            );

          saveSettings();

          if (videoFeed) {
            if (average) {
              drawAllCanvases(accumlator);
            } else {
              drawAllCanvases(tempsFrame);
            }
          }
        }

        offsetXSpan.innerText = "X: " + offset.x.toFixed(2) + "%";
        offsetYSpan.innerText = "Y: " + offset.y.toFixed(2) + "%";
        scaleSpan.innerText = "S: " + offset.scale.toFixed(2);
      }

      function updateSettings() {
        average = avgValue.checked;
        adaptiveRange = adaptiveValue.checked;
        webcamEnabled = webcamEnabledValue.checked;
        currentPalette = palettes[paletteValue.value];

        opacity = parseInt(opacityValue.value, 10);
        opacitySetting.innerText = opacity + "%";

        if (!adaptiveRange) {
          distanceContainer.classList.add("hide");
          minContainer.classList.remove("hide");
          maxContainer.classList.remove("hide");

          rangeMin = parseInt(minValue.value, 10);
          rangeMax = parseInt(maxValue.value, 10);
          minSetting.innerText = rangeMin;
          maxSetting.innerText = rangeMax;
        } else {
          distanceContainer.classList.remove("hide");
          minContainer.classList.add("hide");
          maxContainer.classList.add("hide");

          mindistance = parseInt(distanceValue.value, 10);
          distanceSetting.innerText = mindistance;
        }

        // start/stop webcam if ble is connected

        if (gattServer && gattServer.connected) {
          if (webcamEnabled && !videoFeed) {
            startWebcam();
          } else if (!webcamEnabled && videoFeed) {
            stopWebcam();
          }
        }

        saveSettings();
        if (average) {
          drawAllCanvases(accumlator);
        } else {
          drawAllCanvases(tempsFrame);
        }
      }

      function saveSettings() {
        let saveObj = {
          average,
          adaptiveRange,
          currentPalette: palettes.indexOf(currentPalette),
          opacity,
          rangeMin,
          rangeMax,
          mindistance,
          webcamEnabled,
          offset,
        };
        localStorage.setItem("settings", JSON.stringify(saveObj));
      }

      function loadSettings() {
        let settings = localStorage.getItem("settings");
        if (settings != null) {
          settings = JSON.parse(settings);
          avgValue.checked = settings.average;
          adaptiveValue.checked = settings.adaptiveRange;
          webcamEnabledValue.checked = settings.webcamEnabled;

          if (palettes.length > settings.currentPalette) {
            currentPalette = palettes[settings.currentPalette];
            paletteValue.value = settings.currentPalette;
          }

          opacityValue.value = settings.opacity;
          minValue.value = settings.rangeMin;
          maxValue.value = settings.rangeMax;
          distanceValue.value = settings.mindistance;

          if (settings.offset) {
            offset.x = settings.offset.x;
            offset.y = settings.offset.y;
            offset.scale = settings.offset.scale;
          }
        }
      }

      function map(value, in_min, in_max, out_min, out_max) {
        return (
          ((value - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min
        );
      }

      function getPaletteColor(val) {
        if (val <= 0) {
          return new Color(currentPalette.stops[0]);
        }
        if (val >= 100) {
          return new Color(
            currentPalette.stops[currentPalette.stops.length - 1]
          );
        }
        const stopsCount = currentPalette.stops.length - 1;
        const relevantStop = Math.floor(val / (100 / stopsCount));
        const left = new Color(currentPalette.stops[relevantStop]);
        const right = new Color(currentPalette.stops[relevantStop + 1]);
        const percentage = map(
          val,
          relevantStop * (100 / stopsCount),
          (relevantStop + 1) * (100 / stopsCount),
          0,
          100
        );
        return LinearColorInterpolator.findColorBetween(
          left,
          right,
          percentage
        );
      }

      function getEventOffset(event) {
        if (event.touches) {
          // For touch events
          const rect = event.target.getBoundingClientRect();
          const touch = event.touches[0];
          return {
            offsetX: touch.pageX - rect.left - window.scrollX,
            offsetY: touch.pageY - rect.top - window.scrollY,
          };
        } else {
          // For mouse events
          return {
            offsetX: event.offsetX,
            offsetY: event.offsetY,
          };
        }
      }

      function setMarker(event) {
        const { offsetX, offsetY } = getEventOffset(event);
        const xTherm = Math.round(
          map(offsetX, 0, mainCanvasElem.clientWidth, 0, sizeX)
        );
        const yTherm = Math.round(
          map(
            offsetY,
            0,
            mainCanvasElem.clientWidth * (sizeY / sizeX),
            0,
            sizeY
          )
        );

        // check of out of bounds

        if (xTherm < 0 || xTherm >= sizeX || yTherm < 0 || yTherm >= sizeY) {
          markerCoords = null;
        } else {
          markerCoords = {
            x: offsetX * pixelRatio,
            y: offsetY * pixelRatio,
            xTherm,
            yTherm,
          };
        }

        if (average) {
          drawAllCanvases(accumlator);
        } else {
          drawAllCanvases(tempsFrame);
        }
      }

      function generateFileName() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0");
        const day = String(now.getDate()).padStart(2, "0");
        const hours = String(now.getHours()).padStart(2, "0");
        const minutes = String(now.getMinutes()).padStart(2, "0");
        const seconds = String(now.getSeconds()).padStart(2, "0");
        return `THERMAL_${year}${month}${day}_${hours}${minutes}${seconds}.jpg`;
      }

      function captureCanvas() {
        const canvasUrl = mainCanvasElem.toDataURL("image/jpeg", 0.9);
        const link = document.createElement("a");
        link.href = canvasUrl;
        link.download = generateFileName();
        link.click();
        link.remove();
      }

      // DOM setup

      captureButton.addEventListener("click", captureCanvas);
      connectDisconnectButton.addEventListener("click", connectDisconnect);

      mainCanvasElem.addEventListener("click", setMarker);

      offsetXMinus.addEventListener("click", () => {
        updateOffsets({ x: -offsetStep });
      });
      offsetXPlus.addEventListener("click", () => {
        updateOffsets({ x: offsetStep });
      });

      offsetYMinus.addEventListener("click", () => {
        updateOffsets({ y: -offsetStep });
      });

      offsetYPlus.addEventListener("click", () => {
        updateOffsets({ y: offsetStep });
      });

      scaleMinus.addEventListener("click", () => {
        updateOffsets({ scale: -offsetStep });
      });

      scalePlus.addEventListener("click", () => {
        updateOffsets({ scale: offsetStep });
      });

      mainCanvasElem.addEventListener("mousedown", (e) => {
        mainCanvasElem.addEventListener("mousemove", setMarker);
      });
      mainCanvasElem.addEventListener("mouseup", () => {
        mainCanvasElem.removeEventListener("mousemove", setMarker);
      });

      // Touch event listeners
      mainCanvasElem.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault(); // Prevents the default action to allow touchmove to work
          setMarker(e); // Use the first touch point
        },
        { passive: false }
      );

      mainCanvasElem.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault(); // Prevent scrolling/scaleing action
          setMarker(e); // Use the first touch point
        },
        { passive: false }
      );

      // mainCanvasElem.addEventListener("touchend", (e) => {
      // No need to remove the touchmove listener, it's automatically "removed" after touchend
      // });

      captureButton.classList.add("hide");

      if (paletteValue.options.length != palettes.length) {
        palettes.forEach((pal, index) => {
          paletteValue.options[index] = new Option(pal.name, index);
        });
      }

      if (hardwareFpsValue.options.length == 0) {
        const fpsValues = [0.25, 0.5, 1, 2, 4, 8];
        fpsValues.forEach((fps) => {
          hardwareFpsValue.options[hardwareFpsValue.options.length] =
            new Option(fps + " FPS", fps);
        });
      }

      // exec

      loadSettings();
      updateSettings();
      updateOffsets();
      autoConnectSetup();
    </script>
  </body>
</html>
